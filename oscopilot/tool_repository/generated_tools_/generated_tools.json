{
    "email_fetcher": {
        "code": "import os\nimport imaplib\nimport email\nfrom email.header import decode_header\n\nclass EmailFetcher:\n    \"\"\"\n    A tool to fetch emails and save them as .txt files, along with their attachments.\n    \"\"\"\n    name = \"email_fetcher\"\n    description = \"Fetch the latest emails and save them into folders with their attachments.\"\n\n    def __init__(self, email_address, password, imap_server=\"imap.gmail.com\"):\n        \"\"\"\n        Initialize the EmailFetcher tool.\n\n        Args:\n            email_address (str): Email account address.\n            password (str): Email account password.\n            imap_server (str): IMAP server address (default: Gmail).\n        \"\"\"\n        self.email_address = email_address\n        self.password = password\n        self.imap_server = imap_server\n        self.mail = None\n\n    def connect_to_email_server(self):\n        \"\"\"\n        Connect to the IMAP email server.\n        \"\"\"\n        try:\n            self.mail = imaplib.IMAP4_SSL(self.imap_server)\n            self.mail.login(self.email_address, self.password)\n            print(\"Connected to email server successfully.\")\n        except Exception as e:\n            print(f\"Failed to connect to email server: {e}\")\n            self.mail = None\n\n    def fetch_emails(self, max_emails=5, output_folder=\"working_dir/emails\"):\n        \"\"\"\n        Fetch the latest emails and save them into dedicated folders.\n\n        Args:\n            max_emails (int): Number of latest emails to fetch.\n            output_folder (str): Directory to save emails and their attachments.\n        \"\"\"\n        if not self.mail:\n            print(\"Not connected to the email server.\")\n            return\n\n        # Select the inbox\n        self.mail.select(\"inbox\")\n\n        # Search for all emails\n        status, messages = self.mail.search(None, \"ALL\")\n        if status != \"OK\":\n            print(\"Failed to retrieve emails.\")\n            return\n\n        # Get the latest X emails\n        mail_ids = messages[0].split()\n        latest_email_ids = mail_ids[-max_emails:]\n\n        # Create output folder if it doesn't exist\n        os.makedirs(output_folder, exist_ok=True)\n\n        # Fetch each email\n        for i, email_id in enumerate(latest_email_ids):\n            status, msg_data = self.mail.fetch(email_id, \"(RFC822)\")\n            if status != \"OK\":\n                print(f\"Failed to fetch email with ID: {email_id}\")\n                continue\n\n            for response_part in msg_data:\n                if isinstance(response_part, tuple):\n                    msg = email.message_from_bytes(response_part[1])\n                    self._save_email_with_attachments(msg, i + 1, output_folder)\n\n        print(f\"Saved {len(latest_email_ids)} emails to the '{output_folder}' folder.\")\n\n    def _save_email_with_attachments(self, msg, email_number, output_folder):\n        \"\"\"\n        Save an email and its attachments into a dedicated folder.\n\n        Args:\n            msg (email.message.EmailMessage): The email message to save.\n            email_number (int): The email number for folder naming.\n            output_folder (str): Base directory to save emails and attachments.\n        \"\"\"\n        # Decode the email subject\n        subject = msg[\"Subject\"]\n        if subject:\n            subject, encoding = decode_header(subject)[0]\n            if isinstance(subject, bytes):\n                subject = subject.decode(encoding if encoding else \"utf-8\")\n        else:\n            subject = \"No Subject\"\n\n        # Decode the sender's email address\n        sender = msg.get(\"From\", \"Unknown Sender\")\n\n        # Create a folder for this email\n        email_folder = os.path.join(output_folder, f\"email_{email_number:03d}\")\n        os.makedirs(email_folder, exist_ok=True)\n\n        # Extract email body and attachments\n        body = \"No plain text content found.\"\n        attachments = []\n\n        if msg.is_multipart():\n            for part in msg.walk():\n                content_type = part.get_content_type()\n                content_disposition = str(part.get(\"Content-Disposition\", \"\"))\n\n                if content_type == \"text/plain\" and \"attachment\" not in content_disposition:\n                    # Get the plain text part of the email\n                    body = part.get_payload(decode=True).decode()\n                elif \"attachment\" in content_disposition:\n                    # Extract attachment\n                    filename = part.get_filename()\n                    if filename:\n                        filename, encoding = decode_header(filename)[0]\n                        if isinstance(filename, bytes):\n                            filename = filename.decode(encoding if encoding else \"utf-8\")\n                        attachment_path = os.path.join(email_folder, filename)\n                        with open(attachment_path, \"wb\") as f:\n                            f.write(part.get_payload(decode=True))\n                        attachments.append(attachment_path)\n\n        # Save the email content into a file\n        email_content_file = os.path.join(email_folder, \"email.txt\")\n        with open(email_content_file, \"w\", encoding=\"utf-8\") as f:\n            f.write(f\"Subject: {subject}\\n\")\n            f.write(f\"From: {sender}\\n\")\n            f.write(\"\\n\")\n            f.write(body)\n\n        print(f\"Saved email content to {email_content_file}\")\n\n        # Log saved attachments\n        for attachment in attachments:\n            print(f\"Saved attachment to {attachment}\")\n\n    def close_connection(self):\n        \"\"\"\n        Close the connection to the email server.\n        \"\"\"\n        if self.mail:\n            self.mail.logout()\n            print(\"Disconnected from email server.\")",
        "description": "A tool to fetch emails and save them as "
    },
    "check_word_in_files": {
        "code": "def check_word_in_files(file_paths, target_word):\n    \"\"\"\n    Check if a specific word is present in each text file.\n\n    Args:\n        file_paths (list): List of file paths to check.\n        target_word (str): The word to search for in the text files.\n\n    Returns:\n        list: A list of tuples where each tuple contains the file path and a boolean indicating if the word was found.\n    \"\"\"\n    word_found_list = []\n    for file_path in file_paths:\n        try:\n            with open(file_path, 'r', encoding='utf-8') as file:\n                content = file.read()\n                word_found = target_word in content\n                word_found_list.append((file_path, word_found))\n        except Exception as e:\n            print(f\"Error reading file {file_path}: {e}\")\n            word_found_list.append((file_path, False))\n    \n    return word_found_list",
        "description": "Check if a specific word is present in each text file"
    },
    "fetch_emails": {
        "code": "def fetch_emails(email_address, password, max_emails=5, output_folder=\"/Users/fanyi/OS-Copilot/working_dir/emails\"):\n    \"\"\"\n    Fetch the first 5 emails in the mailbox with the specified email address and password, and save them to the specified output folder.\n\n    Args:\n        email_address (str): Email account address.\n        password (str): Email account password.\n        max_emails (int): Number of emails to fetch (default is 5).\n        output_folder (str): Directory to save the emails (default is '/Users/fanyi/OS-Copilot/working_dir/emails').\n\n    Returns:\n        str: Information message indicating the number of emails saved to the output folder.\n    \"\"\"\n    import os\n    import imaplib\n    import email\n    from email.header import decode_header\n\n    class EmailFetcher:\n        def __init__(self, email_address, password, imap_server=\"imap.gmail.com\"):\n            self.email_address = email_address\n            self.password = password\n            self.imap_server = imap_server\n            self.mail = None\n\n        def connect_to_email_server(self):\n            try:\n                self.mail = imaplib.IMAP4_SSL(self.imap_server)\n                self.mail.login(self.email_address, self.password)\n                print(\"Connected to email server successfully.\")\n            except Exception as e:\n                print(f\"Failed to connect to email server: {e}\")\n                self.mail = None\n\n        def fetch_emails(self, max_emails=5, output_folder=\"working_dir/emails\"):\n            if not self.mail:\n                print(\"Not connected to the email server.\")\n                return\n\n            self.mail.select(\"inbox\")\n\n            status, messages = self.mail.search(None, \"ALL\")\n            if status != \"OK\":\n                print(\"Failed to retrieve emails.\")\n                return\n\n            mail_ids = messages[0].split()\n            latest_email_ids = mail_ids[-max_emails:]\n\n            os.makedirs(output_folder, exist_ok=True)\n\n            for i, email_id in enumerate(latest_email_ids):\n                status, msg_data = self.mail.fetch(email_id, \"(RFC822)\")\n                if status != \"OK\":\n                    print(f\"Failed to fetch email with ID: {email_id}\")\n                    continue\n\n                for response_part in msg_data:\n                    if isinstance(response_part, tuple):\n                        msg = email.message_from_bytes(response_part[1])\n                        self._save_email_with_attachments(msg, i + 1, output_folder)\n\n            return f\"Saved {len(latest_email_ids)} emails to the '{output_folder}' folder.\"\n\n        def _save_email_with_attachments(self, msg, email_number, output_folder):\n            subject = msg[\"Subject\"]\n            if subject:\n                subject, encoding = decode_header(subject)[0]\n                if isinstance(subject, bytes):\n                    subject = subject.decode(encoding if encoding else \"utf-8\")\n            else:\n                subject = \"No Subject\"\n\n            sender = msg.get(\"From\", \"Unknown Sender\")\n\n            email_folder = os.path.join(output_folder, f\"email_{email_number:03d}\")\n            os.makedirs(email_folder, exist_ok=True)\n\n            body = \"No plain text content found.\"\n            attachments = []\n\n            if msg.is_multipart():\n                for part in msg.walk():\n                    content_type = part.get_content_type()\n                    content_disposition = str(part.get(\"Content-Disposition\", \"\"))\n\n                    if content_type == \"text/plain\" and \"attachment\" not in content_disposition:\n                        body = part.get_payload(decode=True).decode()\n                    elif \"attachment\" in content_disposition:\n                        filename = part.get_filename()\n                        if filename:\n                            filename, encoding = decode_header(filename)[0]\n                            if isinstance(filename, bytes):\n                                filename = filename.decode(encoding if encoding else \"utf-8\")\n                            attachment_path = os.path.join(email_folder, filename)\n                            with open(attachment_path, \"wb\") as f:\n                                f.write(part.get_payload(decode=True))\n                            attachments.append(attachment_path)\n\n            email_content_file = os.path.join(email_folder, \"email.txt\")\n            with open(email_content_file, \"w\", encoding=\"utf-8\") as f:\n                f.write(f\"Subject: {subject}\\n\")\n                f.write(f\"From: {sender}\\n\\n\")\n                f.write(body)\n\n            for attachment in attachments:\n                pass\n\n        def close_connection(self):\n            if self.mail:\n                self.mail.logout()\n                print(\"Disconnected from email server.\")\n\n    # Instantiate EmailFetcher and fetch emails\n    email_fetcher = EmailFetcher(email_address, password)\n    email_fetcher.connect_to_email_server()\n    result = email_fetcher.fetch_emails(max_emails, output_folder)\n    email_fetcher.close_connection()\n\n    return result",
        "description": "Fetch the first 5 emails in the mailbox with the specified email address and password, and save them to the specified output folder"
    },
    "email_virus_detection": {
        "code": "from fastapi import APIRouter, HTTPException, File, UploadFile, Depends\nfrom pydantic import BaseModel, Field\nimport os\nimport requests\nimport shutil\n\nrouter = APIRouter()\n\n# \u75c5\u6bd2\u68c0\u6d4b\u5de5\u5177\u7c7b\nclass VirusDetectionTool:\n    def __init__(self, api_url: str, api_key: str) -> None:\n        self.api_url = api_url\n        self.api_key = api_key\n\n    def detect_virus(self, file_path: str) -> dict:\n        \"\"\"\n        Upload file to VirusTotal API and analyze the results.\n        \"\"\"\n        headers = {\"x-apikey\": self.api_key}\n        try:\n            with open(file_path, \"rb\") as file:\n                # Upload file for analysis\n                response = requests.post(f\"{self.api_url}/files\", headers=headers, files={\"file\": file})\n                response.raise_for_status()\n                data = response.json()\n                file_id = data[\"data\"][\"id\"]\n\n            # Fetch analysis results\n            analysis_url = f\"{self.api_url}/analyses/{file_id}\"\n            analysis_response = requests.get(analysis_url, headers=headers)\n            analysis_response.raise_for_status()\n            return analysis_response.json()\n        except requests.exceptions.RequestException as e:\n            raise RuntimeError(f\"API request failed: {e}\")\n\n# \u521d\u59cb\u5316\u75c5\u6bd2\u68c0\u6d4b\u5de5\u5177\nvirus_tool = VirusDetectionTool(\n    api_url=\"https://www.virustotal.com/api/v3\",  # \u4fee\u6539\u4e3a\u4f60\u7684 VirusTotal API URL\n    api_key=os.getenv(\"VIRUSTOTAL_API_KEY\", \"your_api_key_here\")\n)\n\n# \u8bf7\u6c42\u6570\u636e\u6a21\u578b\nclass VirusScanQueryItem(BaseModel):\n    file: UploadFile = File(...)\n\n# \u8def\u7531\u5b9e\u73b0\n@router.post(\"/tools/virus_detection\", summary=\"A tool to scan files for viruses and analyze results.\")\nasync def virus_detection(item: VirusScanQueryItem = Depends()):\n    try:\n        # \u4e34\u65f6\u5b58\u50a8\u4e0a\u4f20\u7684\u6587\u4ef6\n        with open(item.file.filename, \"wb\") as buffer:\n            shutil.copyfileobj(item.file.file, buffer)\n\n        # \u8c03\u7528\u75c5\u6bd2\u68c0\u6d4b\u5de5\u5177\n        analysis_result = virus_tool.detect_virus(file_path=item.file.filename)\n\n        # \u6e05\u7406\u4e34\u65f6\u6587\u4ef6\n        os.remove(item.file.filename)\n\n        # \u5206\u6790\u7ed3\u679c\n        stats = analysis_result.get(\"data\", {}).get(\"attributes\", {}).get(\"stats\", {})\n        malicious_count = stats.get(\"malicious\", 0)\n        harmless_count = stats.get(\"harmless\", 0)\n        suspicious_count = stats.get(\"suspicious\", 0)\n\n        # \u8f93\u51fa\u5206\u6790\u7ed3\u679c\n        return {\n            \"file_name\": item.file.filename,\n            \"malicious_count\": malicious_count,\n            \"harmless_count\": harmless_count,\n            \"suspicious_count\": suspicious_count,\n            \"is_virus_detected\": malicious_count > 0,\n        }\n    except RuntimeError as e:\n        raise HTTPException(status_code=500, detail=str(e))\n",
        "description": "Upload file to VirusTotal API and analyze the results"
    },
    "generate_report": {
        "code": "def generate_report(report_data, report_file_path):\n    \"\"\"\n    Generate a report with the provided data in the specified file.\n\n    Args:\n        report_data (dict): Dictionary containing the report data including the number of files detected, at risk, and the issue details.\n        report_file_path (str): The absolute file path where the report will be generated.\n\n    Returns:\n        str: Information indicating that the report has been successfully generated.\n    \"\"\"\n    try:\n        with open(report_file_path, 'w') as report_file:\n            report_file.write(f\"Number of files detected: {report_data.get('detected_files', 0)}\\n\")\n            report_file.write(f\"Number of files at risk: {report_data.get('at_risk_files', 0)}\\n\")\n            report_file.write(\"Issue Details:\\n\")\n            for file_info in report_data.get('issue_details', []):\n                report_file.write(f\"File: {file_info.get('file_name')}\\n\")\n                report_file.write(f\"Issue: {file_info.get('issue_type')} in {file_info.get('issue_location')}\\n\\n\")\n\n        return \"Report generated successfully.\"\n    except Exception as e:\n        return f\"Error generating report: {str(e)}\"",
        "description": "Generate a report with the provided data in the specified file"
    },
    "read_email_files": {
        "code": "def read_email_files(email_folder):\n    \"\"\"\n    Iterate through each file in the specified email folder to read the content of each file.\n\n    Args:\n        email_folder (str): Directory path where the email files are stored.\n\n    Returns:\n        list: A list of tuples where each tuple contains the email file name and its content.\n    \"\"\"\n    import os\n\n    email_files_content = []\n\n    # Iterate through each file in the email folder\n    for root, _, files in os.walk(email_folder):\n        for file in files:\n            file_path = os.path.join(root, file)\n            with open(file_path, 'r', encoding='utf-8') as f:\n                content = f.read()\n                email_files_content.append((file, content))\n\n    return email_files_content",
        "description": "Iterate through each file in the specified email folder to read the content of each file"
    },
    "read_files": {
        "code": "def read_files(email_folder):\n    \"\"\"\n    Iterate through each file in the specified email folder to read the content of each file.\n\n    Args:\n        email_folder (str): Directory path where the email files are stored.\n\n    Returns:\n        list: A list of tuples where each tuple contains the email file name and its content.\n    \"\"\"\n    import os\n\n    email_files_content = []\n\n    # Iterate through each file in the email folder\n    for root, _, files in os.walk(email_folder):\n        for file in files:\n            file_path = os.path.join(root, file)\n            with open(file_path, 'r', encoding='utf-8') as f:\n                content = f.read()\n                email_files_content.append((file, content))\n\n    return email_files_content",
        "description": "Iterate through each file in the specified email folder to read the content of each file"
    },
    "file_reading": {
        "code": "def file_reading(email_folder):\n    \"\"\"\n    Read all files with names prefixed as 'email_xxx.txt' in the specified email folder.\n    Each file contains the main text content of the email and optional attachments listed as paths within the file.\n\n    Args:\n        email_folder (str): Directory path where the email files are stored.\n\n    Returns:\n        list: A list of tuples where each tuple contains the email file name and its content.\n    \"\"\"\n    import os\n\n    email_files_content = []\n\n    # Iterate through each file in the email folder\n    for root, _, files in os.walk(email_folder):\n        for file in files:\n            if file.startswith('email_') and file.endswith('.txt'):\n                file_path = os.path.join(root, file)\n                with open(file_path, 'r', encoding='utf-8') as f:\n                    content = f.read()\n                    email_files_content.append((file, content))\n\n    return email_files_content",
        "description": "Read all files with names prefixed as 'email_xxx"
    }
}